// #define _POSIX_C_SOURCE 200809L
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int n_global, m_global;
size_t num_threads_global;
const long long *A_g, *B_g;
long long **Rthreads;


void *routine(void *arg){
    const size_t rank = *(unsigned long *)arg;

    const unsigned long long int n_start = (n_global + 1) * rank / num_threads_global; // we need it for the for loop for i = (rank*n_global)/ num_threads_global to i = (rank*n_global+1)/ num_threads_global
    const unsigned long long int n_end = (n_global + 1) * (rank + 1) / num_threads_global;


    for (unsigned long long int i = n_start; i < n_end; i++){
        for(int j=0; j < m_global + 1; j++){
            Rthreads[rank][i + j] += A_g[i] * B_g[j];
        }
    }

    return NULL;
}


long long  *m_parallel(const long long *A, size_t n, const long long *B, size_t m, size_t num_threads, double *time){

    // Initialization and declaration 
    struct timespec begin, end;
    size_t r = n + m + 1;
    num_threads_global = num_threads;
    n_global = n;
    m_global = m;
    A_g = A;
    B_g = B;

    long long *R = calloc(r, sizeof(long long)); 
    if (!R) {
        perror("calloc R");
        return NULL;
    } 
    
        
    Rthreads = malloc(num_threads * sizeof(long long*));
    for (size_t t = 0; t < num_threads; t++) {
        Rthreads[t] = calloc(r, sizeof(long long));
    }


    pthread_t *thread_handles;
    if ((thread_handles = calloc(num_threads, sizeof(pthread_t))) == NULL){
        perror("Failed to create calloc");
    }
    
    unsigned long int *thread_args;
    if ((thread_args = calloc(num_threads, sizeof(unsigned long int))) == NULL){
        perror("Failed to create calloc");
    }

    unsigned long int thread;
    clock_gettime(CLOCK_MONOTONIC, &begin);

    for (thread = 0; thread < num_threads; thread++){
        thread_args[thread] = thread;
        if(pthread_create(&thread_handles[thread], NULL, routine, &thread_args[thread]) != 0){
            perror("Failed to create thread");
        };  
    }

    for (thread = 0; thread < num_threads; thread++){
        if(pthread_join(thread_handles[thread], NULL) != 0){
            perror("Failed to join thread");
        };
    }
#ifdef DEBUG
        printf("\nAll threads joined");
#endif

    for (size_t t = 0; t < num_threads; t++){
        for (size_t i = 0; i < r; ++i){
                R[i] += Rthreads[t][i];
        }
    }
    clock_gettime(CLOCK_MONOTONIC, &end);
    double time_spent = (end.tv_sec - begin.tv_sec) + (end.tv_nsec - begin.tv_nsec) / 1e9;
    *time = time_spent;

    for (size_t t = 0; t < num_threads; t++) {
        free(Rthreads[t]);
    }
    free(Rthreads);
    free(thread_handles);
    free(thread_args);  
    
#ifdef DEBUG
    printf("\n\n");
#endif

    return R;
}